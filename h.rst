h
**

缓存(cache)
============

**应用** 

缓存用于保存需要大量计算的操作结果，或者需要快速访问的数据。

比如一个数量庞大的排序，一个耗时的搜索，网站主页内容，等等。

**定义**

最简单的缓存实现一般只有两个操作，一个是\ ``set``\ ，另一个是\ ``get``\ 。

更新缓存有两种常用策略：

1. 手动更新
2. 自动过期

通常我们可以在数据更新的时候手动更新缓存，比如每当有新数据插入的时候，我们就执行一次\ ``set``\ ，让新缓存覆盖旧缓存。

另一方面，我们可以用\ ``expire``\ 操作给缓存设定一个过期时间，当缓存过期时它被自动删除，然后在每次查找数据的时候查看缓存是否存在，如果缓存不存在则重建缓存，并为缓存设定过期时间，然后返回结果；如果缓存存在，则直接取出缓存里的结果并返回。

缓存的删除操作\ ``delete``\ 通常是可有可无的，其一是因为你可以直接用\ ``set``\ 覆盖旧缓存，其二是可以让缓存自动过期，所以通常不需要删除缓存，只是偶尔在调试的时候会用上。

**实现**

缓存可以用Redis的\ :ref:`string_struct`\ 或\ :ref:`hash_struct`\ 来实现。

字符串实现的优点是可以为每个缓存分别设置过期时间，缺点是比哈希表实现占用更多的空间。

而在哈希表实现中，每个哈希表只能共享同一个过期时间(也即是，放在同一个哈希表中的所有缓存会同时过期)。但是你可以利用这一特点为缓存分类，比如你可以将所有排序操作的缓存放到名为\ ``sort_cache``\ 的哈希表中，而将所有搜索操作的缓存放到名为\ ``search_cache``\ 的哈希表中，然后分别为\ ``sort_cache``\ 和\ ``search_cache``\ 设置不同的过期时间。

并且哈希表实现比字符串实现更节省空间。

.. seealso:: 

    我们通常不对缓存的数量进行限制，如果你需要限制缓存的数量(比如只允许最多100个缓存)，请参考\ :ref:`log`\ 。

    如果你需要实现一些复杂的缓存算法，比如\ `Most Recently Used(MRU) <http://en.wikipedia.org/wiki/MRU_cache>`_\ 或\ `Least Recently Used(LRU) <http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used>`_\ 请使用\ :ref:`sorted_set_struct`\ 。

    关于哈希表比字符串更节约空间的讨论，请参考Redis官方的\ `Memory optimization文档 <http://redis.io/topics/memory-optimization>`_\ 。

字符串实现
-----------

.. literalinclude:: source/h/cache/string_implement.py

哈希表实现
-----------

和字符串实现不同，为了方便管理，这里用\ ``category``\ 参数作分类，将每个哈希表组织成一个对象实例。

\ ``expire``\ 设置整个哈希表的过期时间，而\ ``ttl``\ 返回剩余的生存时间。

\ ``size``\ 返回哈希表内缓存数目。

.. literalinclude:: source/h/cache/hash_implement.py
